#### 1. 第一道是快乐消消乐，就是给定一个字符串将相邻的两个字符进行消除，最后返回消除后字符串的总长数  (真题)
    例子： ggA, 结果 1
    消除 gg 后剩下 A ，因此最后结果 1
    例子2：abccbe，结果 2
    消除 cc 后字符串变成 abbe 在消除 bb，变 ae，因此结果 2
    
        public static String xiaoXiaoLe(String str){
          int length = str.length();
          Deque<Character> stack = new LinkedList<>();
          for (int i = 0 ; i<length; i++){
              char ch = str.charAt(i);
              if (stack.isEmpty()){
                  stack.push(ch);
                  continue;
              }
              if (stack.peek() == ch){
                  stack.pop();
              }else {
                  stack.push(ch);
              }
          }
          return String.valueOf(stack.size());
      }
      
#### 2.给两个字符串，targe，和 source，查找 targe 是否由 source 删除某些字符得到的，是返回开始的最大下标，否返回 -1; （真题-解法有误）
       例子：
       输入：
       abc
       abcaybec
       结果为 3
       解释：abc 可以由下面 abcaybec 删除 aybec 和 abcye 而来，删除 abcye 是最后的这个组成的 a 在下标位置 3 下，因此返回 3
       
            public static int targeAndSource(String targe, String source){
                int tarStr = targe.length();
                int sourStr = source.length();
                if (sourStr < tarStr || targe.isEmpty() || source.isEmpty()){
                    return -1;
                }
                Map<Character,Integer> map = new HashMap<>();
                for (int i = 0; i < tarStr; i++){
                    char tarCh = targe.charAt(i);
                    for (int j =0; j < sourStr-tarStr; j++){
                        char sourCh = source.charAt(j);
                        if (sourCh != tarCh){
                            continue;
                        }else {
                            map.put(sourCh,j);
                        }

                        if (map.size() == tarStr){
                            return j+1;
                        }

                    }
                }
                return -1;
            }
            
#### 3.放苹果
        把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。

        数据范围：0≤m≤10 ，1≤n≤10 。

        本题含有多组样例输入。
        输入：7 3
        输出：8
        解题思路：设f(m,n)为m个苹果，n个盘子的放法数目，则先对n作讨论，
        
       （1）当n>m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n>m)f(m,n)=f(m,m)
       
       （2）当n<=m：不同的放法可以分成两类：

　　　　   (a)有至少一个盘子空着，即相当于f(m,n)=f(m,n-1);
    
　　　　   (b)所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n)=f(m-n,n).而总的放苹果的放法数目等于两者的和，
       即f(m,n)=f(m,n-1)+f(m-n,n)递归出口条件说明：当n=1 时，所有苹果都必须放在一个盘子里，所以返回1；当没有苹果可放时，定义为1种放法；
       递归的两条路，第一条n会逐渐减少，终会到达出口n==1;第二条m会逐渐减少，因为n>m时，我们会returnf(m,m)所以终会到达出口m==0．
　　综上递推公式为：

            import java.util.Scanner;
            public class Main{
              public static void main(String args[]){
                 Scanner scan =  new Scanner(System.in);
                 while(scan.hasNextInt()){
                     int apple = scan.nextInt();
                     int pan = scan.nextInt();
                     System.out.println(cal(apple,pan));
                 }
              }

                public static int cal (int apple,int pan){
                    /* 分苹果可分为两种情况：
                      f(a,p) 为可以分的次数,a为苹果；p为盘子；
                      对p进行讨论，
                      第一种情况：p>a 时，p-a个盘子永远是空着的，不考虑，f(p,p)
                      第二种情况：a > p时，分一下两种情况：
                         1.至少有一个盘子是空着的；f(a,p) = f(a,p-1)
                         2.所有的盘子都有苹果；f(a,p) = f(a-p,p);
                         总情况数等于 f(a,p-1) + f(a-p,p) ;
                         递归的出口是当a = 1 时 return 1;
                                   当p = 1 时 return 0;
                    */
                    if(apple < 0 || pan <= 0){
                       return 0;
                    }
                     //细分到苹果数为一或盘子数为一的情况返回一
                    if(apple == 1 || pan == 1 || apple == 0){
                        return 1;
                    }
                   return cal(apple,pan-1) + cal(apple - pan, pan);
                }
            }
#### HJ5 进制转换
    接收一个16进制的数，输出为该数值的10进制数；
    输入：0xA ， 0xAA
    输出：10,170
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            while (sc.hasNext()){
                String str = sc.next();
                String subStr = str.substring(2, str.length());
                int result = Integer.parseInt(subStr, 16);
                System.out.println(result);
            }
        }
    
#### HJ6 质数因子
    输入一个正整数，按照从小到大的顺序输出它的所有质数因子（重复的也要列举）；
    例：输入 180
        输出 2 2 3 3 5
   解题思路：1. 对于一个数，他的质因数必然分布在该数的平方根两侧，而且**大于平方根的质因数最多只有一个，且必然是分解到最后所剩余的商**。    
             2. 取余： a%b=a-(a/b)*b
             
             public static void main(String args[]){
                Scanner sc = new Scanner(System.in);
                long num = sc.nextLong();
                double k = Math.sqrt(num);
                for(long i = 2;i <= k; i++){
                    while(num % i == 0){
                        System.out.print(i + " ");
                        num /= i;
                    }
                }
                System.out.println(num == 1 ? "": num+" ");
            }
                
#### HJ7 取近似值
    写一个程序，接收一个正浮点数值，输出该数值的近似整数值。若果小数点后数>=0.5,向上取整，<0.5,向下取整。
    例：输入：5.5
        输出： 6
      
            public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                float v = sc.nextFloat();
                int round = Math.round(v);
                System.out.println(round);
            }
            
#### HJ8 合并表记录      
    数据表记录包含表索引和数值（int 范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值求和，输出按照key值升序
    0 <= index <= 1111111
    1 <= value <= 100000
    先输入键值对的个数n，然后输入键值对，以空格隔开；
    例：  4 
          0 1
          0 2
          1 2
          3 4
          
   返回值
          0 3          
          1 2          
          3 4   
          
          
       public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            while (sc.hasNext()) {
                int count = sc.nextInt();
                Map<Integer, Integer> map = new TreeMap<>();
                for (int i = 0; i < count; i++) {
                    int key = sc.nextInt();
                    int value = sc.nextInt();
                    if (map.containsKey(key)) {
                        value = map.get(key) + value;
                    }
                    map.put(key, value);
                }
                Set<Integer> keys = map.keySet();
                for (Integer key : keys) {
                    System.out.println(key + " " + map.get(key));
                }
            }
        }   
        
#### HJ9 提取不重复数
    输入一个Int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数；
    保证最后一位不是0
    例：输入 9876673； 输出：37689
    
     public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int target = sc.nextInt();
            String str = String.valueOf(target);
            int size = str.length();
           List<Character> list = new ArrayList<>();
            while (size != 0) {
                size--;
                if (!list.contains(str.charAt(size))){
                    list.add(str.charAt(size));
                }
            }
            StringBuffer sb = new StringBuffer();
            for (Character character : list) {
                sb.append(character);
            }
            System.out.println(Integer.parseInt(sb.toString()));
        }
        
#### HJ10 字符个数统计       
    编写一个函数，计算字符串中含有的不同字符的个数。字符在ASCII码范围内（0~127,包含0和127）
    换行表示结束符，不再计算范围之内。多个相符的字符只计算一次；比如abaca 只有a,b,c三个不同的字符，输出3；
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str = sc.nextLine();
            Map<Character,Character> map = new TreeMap<>();
            int size = str.length();
            for (int i = 0; i < size; i++) {
                char ch = str.charAt(i);
                if (map.containsKey(str.charAt(i))){
                    continue;
                }
                map.put(ch,ch);
            }
            System.out.println(map.size());
        }
        
#### HJ12 字符串反转
    接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串
    输入：abcd 输出：dcba
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str = sc.nextLine();
            int size = str.length();
            StringBuffer sb = new StringBuffer();
            while (size != 0){
                size--;
                sb.append(str.charAt(size));
            }
            System.out.println(sb.toString());
        }
        
#### HJ13 句子逆序
    将一个英文语句以单词为单位逆序排放，
    例： i am a boy  输出：boy a am i
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str = sc.nextLine();
            String[] arrStr = str.split("\\ ");
            int size = arrStr.length;
            StringBuffer sb = new StringBuffer();
            while (size != 0){
                size--;
                sb.append(arrStr[size]);
                if (size != 0){
                    sb.append(" ");
                }

            }
            System.out.println(sb.toString());
        }
        
#### HJ14 句子逆序
    给定那个字符串，请对那个字符串按照字典序排列
    输入： 9  输出：
        cap      boot
        to       cap
        boot     to
        
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            while (sc.hasNext()) {
                int count = sc.nextInt();
                List<String> list = new ArrayList<>();
                for (int i = 0; i < count; i++) {
                    String str = sc.next();
                    list.add(str);
                }
                Collections.sort(list);
                for (String string : list) {
                    System.out.println(string);
                }
            }
        }
        
#### HJ15 求Int型的正整数，计算出该int型数据在内存中存储时1的个数。
        输入：5 输出：2 ；  输入：0；输出：0；
        
            public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int num  = sc.nextInt();
                String str = Integer.toBinaryString(num);
                int count = 0;
                for (int i = 0; i < str.length(); i++) {
                    if (str.charAt(i) == '1'){
                        count++;
                    }
                }
                System.out.println(count);
            }
            
#### HJ17 坐标移动
    开发一个坐标计算工具，A表示左移，D表示向右移；W表示向上；S表示向下；从（0,0）开始，从输入字符串中提取一些坐标，并输出最终结果；
    例：输入：A10；S20；W10；D30；X;A1A;B10A11;;A10;
        (0,0)开始，A10->(-10,0);S20->(-10,-20);W10->(-10,-10);D30->(20,-10); x->无效；A1A-> 无效；B10A11->无效；A10->(10,-10)
        输出：（-10,10）
        
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str = sc.nextLine();
            String[] strArr = str.split(";");
            Map<Character, Integer> map = new HashMap<>();
            map.put('A', 0);
            map.put('D', 0);
            map.put('W', 0);
            map.put('S', 0);
            for (int i = 0; i < strArr.length; i++) {
                String strNew = strArr[i];
                if (strNew.isEmpty()) {
                    continue;
                }
                char ch = strNew.charAt(0);
                if (map.containsKey(ch)) {
                    String sub = strNew.substring(1, strNew.length());
                    int num = 0;
                    try {
                        num = Integer.parseInt(sub);
                    } catch (NumberFormatException e) {
                        continue;
                    }
                    Integer integer = map.get(strNew.charAt(0));
                    int result = num + integer;
                    map.put(ch, result);
                }
            }
            Integer l = map.get('D') - map.get('A');
            Integer r = map.get('W') - map.get('S');
            System.out.println(l + "," + r);
        }
        
#### HJ18 识别有效的 IP地址和掩码并进行分类
     * 根据IP和对应的掩码，将IP分为以下7类：
     * A类：1.0.0.0 - 126.255.255.255
     * B类：128.0.0.0 - 191.255.255.255
     * C类：192.0.0.0 - 223.255.255.255
     * D类：224.0.0.0 - 239.255.255.255
     * E类：240.0.0.0 - 255.255.255.255
     * 错误掩码：
     * 私网：10.0.0.0 - 10.255.255.255
     * 172.16.0.0 - 172.31.255.255
     * 192.168.0.0 - 192.168.255.255
     * 子网掩码为为禁止下前面都是连续的1，然后全是0；（例如：255.255.255.32是一个非法的掩码；二进制下全是1或者全是0就是一个非法掩码）
     * 忽略【0.*.*.*】 和【27.*.*.*】；私有IP和其他IP类型不冲突；
     /*思路：1.根据~将字符串分割，分成ip和mask；验证IP是否合法，不合法直接跳过，不需要验证子网掩码；
           2.分别验证IP和子网是否合法；
           2.1 验证IP的时候判断是否符合IP地址的要求，不符合返回false;
           2.2 验证子网掩码过程中，判断是否符合子网掩码的要求，不符合就返回false;
               11111110 (254);11111100(252);11111000(248);11110000(240);1110000(224);
               11000000(191);10000000(128),全0全1都不合法；
           2.3 若果IP和掩码都合法，则判断是哪一类IP；*/
          
          public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int[] count = new int[7];
                while (!sc.hasNext("0")) {
                    String input = sc.nextLine();
                    String[] sp = input.split("~");
                    String ip = sp[0]; // IP地址
                    String mask = sp[1]; // 子网掩码

                    String[] ips = ip.split("\\.");
                    int num1 = 0;
                    try {
                        num1 = Integer.parseInt(ips[0]);
                        Integer.parseInt(ips[1]);
                        Integer.parseInt(ips[2]);
                        Integer.parseInt(ips[3]);
                    } catch (NumberFormatException e) {
                        count[5]++;
                        continue;
                    }

                    // 1. 先判断IP是否合法
                    boolean isIp = isIP(ip);
                    // 2. 判断子网掩码是否合法
                    boolean isMask = isMask(mask);

                    if (isIp && isMask) {
                        // 对IP分类
                        count = countIp(ip, count);
                    } else if ((isIp == false || isMask == false) && num1 != 127 && num1 != 0) {
                        count[5]++;
                    }
                }
                for (int i = 0; i < count.length; i++) {
                    System.out.print(count[i] + " ");
                }
            }

            private static int[] countIp(String ip, int[] count) {
                String[] ips = ip.split("\\.");
                int first = Integer.parseInt(ips[0]);
                // 是否为私有Ip
                if (isPrivateIP(ips)) {
                    count[6]++;
                }

                //判断其他地址范围
        /*        A类地址1.0.0.0~126.255.255.255;
                B类地址128.0.0.0~191.255.255.255;
                C类地址192.0.0.0~223.255.255.255;
                D类地址224.0.0.0~239.255.255.255；
                E类地址240.0.0.0~255.255.255.255*/
                if (first >= 1 && first <= 126)
                    count[0]++;
                else if (first >= 128 && first <= 191)
                    count[1]++;
                else if (first >= 192 && first <= 223)
                    count[2]++;
                else if (first >= 224 && first <= 239)
                    count[3]++;
                else if (first >= 240 && first <= 255)
                    count[4]++;
                return count;
            }

            private static boolean isPrivateIP(String[] ips) {
                if (Integer.parseInt(ips[0]) == 10) {
                    return true;
                } else if (Integer.parseInt(ips[0]) == 172 && (Integer.parseInt(ips[1]) > 15 && Integer.parseInt(ips[1]) < 32)) {
                    return true;
                } else if (Integer.parseInt(ips[0]) == 192 && Integer.parseInt(ips[1]) == 168) {
                    return true;
                }
                return false;
            }

            private static boolean isMask(String ip) {
                String[] masks = ip.split("\\.");
                int[] maskRange = {254, 252, 248, 240, 224, 192, 128, 0};
                Boolean flag = false;
                List<Integer> list = new ArrayList<>();
                for (int i = 0; i < maskRange.length; i++) {
                    list.add(maskRange[i]);
                }
                if ("255".equals(masks[0]) && "255".equals(masks[1]) && "255".equals(masks[2])) {
                    if (list.contains(Integer.parseInt(masks[3]))) {
                        flag = true;
                    }
                } else if ("255".equals(masks[0]) && "255".equals(masks[1])) {
                    if (list.contains(Integer.parseInt(masks[2])) && "0".equals(masks[3])) {
                        flag = true;
                    }
                } else if ("255".equals(masks[0])) {
                    if (list.contains(Integer.parseInt(masks[1])) && "0".equals(masks[2]) && "0".equals(masks[3])) {
                        flag = true;
                    }
                } else if (list.contains(Integer.parseInt(masks[0]))) {
                    if ("0".equals(masks[1]) && "0".equals(masks[2]) && "0".equals(masks[3])) {
                        flag = true;
                    }
                }
                return flag;
            }

            private static boolean isIP(String ip) {
                // 1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时可以忽略
                String[] ips = ip.split("\\.");
                Boolean flag = true;
                for (int i = 0; i < ips.length; i++) {
                    // 非法判断
                    if (ips[i].length() <= 0 || ips[i] == "") {
                        flag = false;
                    }
                }
                return flag;
            }
    
#### HJ20 密码验证合格程序
     一组或多组字符串，每组占一行； 符合要求输出：OK， 否则输出NG；
     * 1. 长度超过8位；
     * 2. 包括大小写字母.数字。其他符号，以上四种至少三种
     * 3. 不能有长度大于2的不含公共元素的子串重复（注：其他符号不含空格或换行） xxb21xxb 不属于重复，因为包含供公共元素；
     输入： 021Abc9000   输出：OK
            021Abc9Abc1       NG
            021ABC90000       NG
            021$bc9000        OK
            
          public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                while (sc.hasNext()) {
                    String str = sc.nextLine().trim();
                    int size = str.length();
                    // 1. 判断长度超过8位
                    Boolean flag1 = size >= 8;
                    // 2. 判断是否包含大小写字母，数字，其他符号；至少包含以上三种；
                    Boolean flag2 = isContainsThree(str);
                    // 3. 判断是否有重复字符串；
                    Boolean flag3 = isDuplicateStr(str);

                    if (flag1 && flag2 && flag3) {
                        System.out.println("OK");
                    } else {
                        System.out.println("NG");
                    }
                }
            }

            private static boolean isContainsThree(String str) {
                Map<String, Integer> map = new HashMap<>();
                for (int i = 0; i < str.length(); i++) {
                    char charAt = str.charAt(i);
                    byte result = (byte) charAt;
                    // 是否包含数字
                    if ('0' <= result && result <= '9') {
                        map.put("number", 1);
                    } else if ('A' <= result && result <= 'Z') {
                        // 是否包含大写字母
                        map.put("uppercase", 1);
                    } else if ('a' <= result && result <= 'z') {
                        // 是否包含小写字母
                        map.put("lowercase", 1);
                    } else {
                        // 不属于上述三者则判定为特殊字符；
                        map.put("special", 1);
                    }
                }

                if (map.size() >= 3) {
                    return true;
                }
                return false;
            }

            // 是否存在长度大于2且不含公共元素的重复字符串
            private static Boolean isDuplicateStr(String str) {
                char[] chars = str.toCharArray();
                for (int i = 0; i < chars.length - 2; i++) {
                    String tar = str.substring(i, i + 3);
                    String source = str.substring(i + 2);
                    if (containsPublicStr(tar)) {
                        continue;
                    }
                    if (source.contains(tar)) {
                        return false;
                    }
                }
                return true;
            }

            // 是否包含公共元素；
            private static boolean containsPublicStr(String tar) {
                char[] chars = tar.toCharArray();
                for (int i = 0; i < chars.length - 1; i++) {
                    if (chars[i] == chars[i + 1]) {
                        return true;
                    }
                }
                return false;
            }  
            
#### HJ21 简单密码
         * 密码转换规则：
         * 按手机上的9键输入法，将简单密码中的小写字母转换成对应的数字键；
         * 将简单密码中的大写字母转换成小写后在后移一位， Z往后移1位是a；
         * 输入：YUANzhi1987  输出：zvbo9441987
          
          
          public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str = sc.nextLine().trim();
            StringBuffer sb = new StringBuffer();
            int size = str.length();
            for (int i = 0; i < size; i++) {
                char ch = str.charAt(i);
                if ('a' <= ch && ch <= 'z') {
                    if ("abc".contains(String.valueOf(ch))) {
                        sb.append(2);
                    } else if ("def".contains(String.valueOf(ch))) {
                        sb.append(3);
                    } else if ("ghi".contains(String.valueOf(ch))) {
                        sb.append(4);
                    } else if ("jkl".contains(String.valueOf(ch))) {
                        sb.append(5);
                    } else if ("mno".contains(String.valueOf(ch))) {
                        sb.append(6);
                    } else if ("pqrs".contains(String.valueOf(ch))) {
                        sb.append(7);
                    } else if ("tuv".contains(String.valueOf(ch))) {
                        sb.append(8);
                    } else if ("wxyz".contains(String.valueOf(ch))) {
                        sb.append(9);
                    }
                } else if ('A' <= ch && ch <= 'Z') {
                    if (ch == 'Z') {
                        sb.append('a');
                    } else {
                        int n = (int) ch;
                        char re = (char) (n + 1);
                        sb.append(re);
                    }
                } else {
                    sb.append(ch);
                }
            }
            System.out.println(sb.toString().toLowerCase());
        }
        
        
#### HJ22 汽水瓶

            每三个空瓶子可以换一瓶汽水，10个空瓶子可以喝5瓶汽水； 先用9个空瓶子换3瓶汽水。喝完之后再用3个瓶子换1瓶，
            此时有两个空瓶子，再找老板借1瓶喝完汽水把瓶子给他，就可以喝5瓶
            输入： 10 ， 输入：5
                    3 ，       1
                    81，       40
                    0

             public static void main(String[] args) {
                    Scanner sc = new Scanner(System.in);
                    List<Integer> list = new ArrayList<>();
                    while (!sc.hasNext("0")) {
                        // 喝过的次数
                        int count = 0;
                        // 空瓶子数
                        int ping = sc.nextInt();
                        int result = cal(ping, count);
                        list.add(result);
                    }
                    for (Integer integer : list) {
                        System.out.println(integer);
                    }
                }

                /**
                 * 计算可以喝几瓶
                 *
                 * @param ping  空瓶子
                 * @param count 喝的次数
                 * @return 喝几次
                 */
                private static int cal(int ping, int count) {
                    // 剩两个空瓶子时可找老板借一个
                    if (ping == 2) {
                        ping += 1;
                    }
                    if (ping < 2) {
                        return count;
                    }
                    ping = ping - 3;
                    count++;
                    ping++;
                    return cal(ping, count);
                }  
                
#### HJ23 删除字符串中出现次数最少的字符
        实现删除字符中出现次数最少的字符，若出现次数最少的字符有多个，则把出现次数最少的字符都删除。
        输出删除这些单词后的字符串，保留的字符串按原来顺序输出；
        只输入小写字母，长度小于20；
        例： abcdd  输出：dd
             aabcddd 输出 aaddd
         
         public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                while (sc.hasNext()){
                    String str = sc.nextLine().trim().toLowerCase();
                    HashMap<Character,Integer> map = new HashMap<>();
                    int min = Integer.MAX_VALUE;
                    int size = str.length();
                    for (int i = 0; i < size; i++) {
                        char ch = str.charAt(i);
                        if (!map.containsKey(ch)){
                            map.put(ch,1);
                            min = Math.min(min,1);
                        }else {
                            Integer count = map.get(ch) + 1;
                            map.put(ch,count);
                            if (!map.containsValue(min)){
                                min = count;
                            }
                        }
                    }
                    for (int i = 0; i < size; i++) {
                        if (min != map.get(str.charAt(i))){
                            System.out.print(str.charAt(i) + "");
                        }
                    }
                    System.out.println();
                    map.clear();

                }
            }
            
#### HJ24 合唱队
        
     * N位同学站成一排，音乐老师要请其中的（N-K）为同学出列，使得剩下的K位同学排成队形；
     * 计算出最少出列多少学生，是的同学排成合唱队
     * 注意：不改变队列元素的先后顺序（只剔除，不排序） 且 不要求最高同学左右人数必须相等；
     * 例： 186 186 150 200 160 130 197 200  排序后为：186 200 160 130 或者 150 200 160 130
     * 思路： 1.先找出第i个数左侧的最长升序子序列长度，
     *       2.找到每个位置右侧最长的下降子序列长度，
     *       3.所有位置的最长子序列长度 = 左侧最长子序列长度 + 右侧最长子序列长度 -1 （因为该位置被算了两次所以建1）
     *       4.用输入字符串数组的长度 - 最长子序列的长度 = 需要剔除的K个同学；
     
         public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int size = sc.nextInt();
            int[] arr = new int[size];
            for(int i =0; i< size; i++){
                arr[i] = sc.nextInt();
            }


            int[] leftArr = new int[size];
            leftArr[0] = 1;
            int[] rightArr = new int[size];
            leftArr[size-1] = 1;

            // 左侧最长升序串的长度
            for(int i =0;i<size;i++){
                leftArr[i] = 1;
                for(int j = 0; j < i;j++){
                    if(arr[i] > arr[j]){
                        leftArr[i] = Math.max(leftArr[i],leftArr[j] + 1);
                    }
                }
            }
            // 右侧最长降序串的长度
            for(int i =size-1;i>=0;i--){
                rightArr[i] = 1;
                for(int j = size-1; j > i;j--){
                    if(arr[i] > arr[j]){
                        rightArr[i] = Math.max(rightArr[i],rightArr[j] + 1);
                    }
                }
            }

           // 每个索引位置的最长子序列的长度
            int[] result = new int[size];
            int max = 1;
            for(int i =0;i < size; i++){
                result[i] = leftArr[i] + rightArr[i] -1;
                max = Math.max(result[i],max);
            }
            System.out.println(size - max);
        }
   
#### HJ25 数据分类处理

     * 输入1组整数序列I和1组规则整数序列R；I和R 的第一个整数位序列的个数（序列的个数不包含第一个整数）
     *
     * 输入：i 15,123,456,786,453,46,7,5,3,665,453456,745,456,786,453,123; 
     *      R 5,6,3,6,3,0
     * 输出：30,3,6,0,123,3,453,7,3，9,453456,13,453,14,123,6,7,1,456,2,786,4,46,8,665,9,453456,11,456,12,786
     *      30 -- 后续有30个数；
     *      3  -- R从小到大排序的第一个数，（第一个为0，但没有满足条件的I，不输出0，而输出下一个3）
     *      6  -- 存在6个包含3的I
     *      0  -- 123所在的原序号为0
     *      123 -- 123包含3，满足条件
     *      
     * 说明：将序列R：5,6,3,6,3,0（第一个5表明后续有5个整数），排序去重可得 0 3 6；
     *      序列I中没有包含0的元素, 所以不输出R0；
     *      序列I中包含3的元素有：I[0] 123; I[3] 453; I[7] 3; I[9] 453456; I[13] 453 I[14] 123
     *      序列中包含6的元素有....
    
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            int sizeI = sc.nextInt();
            List<String> listI = new ArrayList<>();
            for(int i = 0; i < sizeI; i++){
                listI.add(String.valueOf(sc.nextInt()));
            }
            int sizeR = sc.nextInt();
            StringBuffer result = new StringBuffer();
            Set<Integer> listR = new TreeSet<>();
            for(int i =0;i <sizeR; i++){
                listR.add(sc.nextInt());
            }
            // 结果集总数
            int num = 0;
            for(Integer in : listR){
                Map<Integer,String> map = new HashMap<>();
                // 包含该字符的个数
                int count = 0;
                for(int i = 0; i < listI.size(); i++){
                    if(listI.get(i).contains(in.toString())){
                        map.put(i,listI.get(i));
                        count++;
                    }
                }
                if(count != 0){
                    num += map.size() * 2 + 2;
                    result.append(in + " " + count + " ");
                }

                Set<Integer> keys =  map.keySet();
                // 需要排序，set无序
                List<Integer> aa = new ArrayList<>();
                for (Integer integer : keys) {
                   aa.add(integer);
                }
                Collections.sort(aa);
                for (Integer integer : aa) {
                    String str = map.get(integer);
                    result.append(integer +" " + str + " ");
                }
            }
             String s = num +" " + result.toString();
             System.out.println(s);
        }
        
#### HJ26 数据分类处理

     * 将输入的字符串按如下顺序排列：
     * 1.英文字母从A到Z，不区分大小写；  输入： Type 输出：epTy
     * 2.同一个英文字母的大小写同时存在则按顺序排列  输入：BabA 输出：aABb
     * 3.非英文字母的其他字符保持原来的位置   输入：By?e 输出：Be?y
     
     public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()){
            String str = sc.nextLine();
            String result = sort(str);
            System.out.println(result);
        }
    }

    private static String sort(String str) {
        List<Character> list = new ArrayList<>();
        StringBuffer result = new StringBuffer();
        // 先取出所有的字母
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            if (Character.isLetter(ch)){
                list.add(ch);
            }
        }
        // 将所有的字母先排好序 BabA -> baba -> aabb  -> aABb
        list.sort(new Comparator<Character>() {
            @Override
            public int compare(Character o1, Character o2) {
                return Character.toLowerCase(o1) - Character.toLowerCase(o2);
            }
        });
        // 若不是字母则直接添加
        // str : BabA   list:a A B b
        for (int i = 0, j = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            if (Character.isLetter(ch)){
                result.append(list.get(j++));
            }else {
                result.append(ch);
            }
        }
        return result.toString();
    }

#### HJ27 查找兄弟单词

     * 兄弟单词：交换该单词的字母顺序，不添加，删除，修改，原有的字母生成新的单词。
     * 兄弟单词要求跟原来的单词的顺序不同，例如ab 和 ba  是兄弟单词，ab 和 ab 不是；
     * 给定你n个单词，再输入1个单词target，寻找target的兄弟单词里，按字典顺序排列后第K个单词，和兄弟单词的个数
     * 输入：3 abc bca cab abc 1 输出：2 bca；
     * 6 cab ad abcd cba abc bca abc 1 输出：3 bca
     
     public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            int size = sc.nextInt();
            Set<String> source = new TreeSet<>();
            for (int i = 0; i < size; i++) {
                source.add(sc.next());
            }

            String target = sc.next();
            int index = sc.nextInt();
            Set<String> result = new TreeSet<>();
            for (String str : source) {
                int count = 0;
                for (int i = 0; i < target.length(); i++) {
                    // 如果源数组中的单词包含了目标单词的所有字符，并且长度相等且不是目标单词本身，则就是兄弟单词
                    if (str.contains(String.valueOf(target.charAt(i)))) {
                        count++;
                    }
                }
                if (count == str.length() && !str.equals(target)) {
                    result.add(str);
                }
            }

            System.out.println(result.size());
            int count = 0;
            for (String s : result) {
                count++;
                if (count == index){
                    System.out.println(s);
                }
            }
        }
    }

#### HJ28 字符串加密

     * 加密规则：内容是英文字母时，则用英文字母的后一个字母替换，同时字母变换大小写，
     * 如字母a时则替换成B，字母Z时转为a
     * 当内容是数字时则把该数字加1，如0替换1,1替换成2,9替换成0；
     * 解密为加密的逆过程；
     输入： abcde12345  输出：BCDEF23456
            BCDEF23456        abcde12345
            
        public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()){
            String str1 = sc.nextLine();
            String str2 = sc.nextLine();

            // 编译加密
            System.out.println(encode(str1));
            // 解密
            System.out.println(decode(str2));

        }
    }

    // 解密 BCDEFGH
    private static String decode(String str) {
        StringBuffer sb = new StringBuffer();
        int size = str.length();
        for (int i = 0; i < size; i++) {
            char ch = str.charAt(i);
            if ('a' <= ch && ch <= 'z'){
                if ('a' == ch){
                    sb.append('Z');
                }else {
                    int by = (int) ch;
                    char re = (char) (by - 32 - 1);
                    sb.append(re);
                }
            }else if('A' <= ch && ch <= 'Z'){
                if ('A' == ch){
                    sb.append('z');
                }else {
                    int by = (int) ch;
                    char re = (char) (by + 32 -1 );
                    sb.append(re);
                }
            }else if('0' <= ch && ch <= '9'){
                if ('0' == ch){
                    sb.append(9);
                }else {
                    int by = (int) ch;
                    char re = (char) (by - 1);
                    sb.append(re);
                }
            }
        }
        return sb.toString();
    }
    // 加密
    private static String encode(String str) {
        StringBuffer sb = new StringBuffer();
        int size = str.length();
        for (int i = 0; i < size; i++) {
            char ch = str.charAt(i);
            if ('a' <= ch && ch <= 'z'){
                if (ch == 'z'){
                    sb.append('A');
                }else {
                    int by = (int) ch;
                    char re = (char) (by - 32 + 1);
                    sb.append(re);
                }
            }else if ('A' <= ch && ch <= 'Z'){
                if (ch == 'Z'){
                    sb.append('a');
                }else {

                }
            }else if('0' <= ch && ch <= '9'){
                if (ch == '9'){
                    sb.append(0);
                }else {
                    int by = (int) ch;
                    char re = (char) (by + 1);
                    sb.append(re);
                }
            }
        }
        return sb.toString();
    }    
    
#### HJ30 字符串合并处理
    1.输入两个字符串Str1 和 Str2 进行合并。给定字符串“dec”,“fab” 合并后生成的字符串为“decfab”；
    2.对合并后的字符串排序，要求：下标为奇数的字符和下标为偶数的字符分别从小到大排序。
      偶数下标：'d','c','a'; 奇数下标:'e','f','b' 得到 “acd”， “bef” ;对刚才的字符串排序后得到“abcedf”
    3.排序后的字符串中‘0’-‘9’；‘a’-‘f’; ‘A’-‘F’转换，对以上16进制的字符转为二进制并倒叙，再转为16进制，再大写输出；
      输入： ‘dec’ “fab” 输出：“5D37BF”  输入：“ab CD” 输出：“3B5D”；
      
          public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            String str1 = sc.nextLine();
            String str2 = sc.nextLine();
            String source = str1 + str2;
            int size = source.length();
            List<Character> sb1 = new ArrayList<>();
            List<Character> sb2 = new ArrayList<>();
            // 拆分
            for (int i = 0; i < size; i++) {
                if (i % 2 == 0) {
                    sb1.add(source.charAt(i));
                } else {
                    sb2.add(source.charAt(i));
                }
            }
            // 排序
            Collections.sort(sb1);
            Collections.sort(sb2);
            // 拼接
            StringBuffer buf = new StringBuffer();
            for (int i = 0; i < size; i++) {
                if (i % 2 == 0) {
                    buf.append(sb1.get(i / 2));
                } else {
                    buf.append(sb2.get(i / 2));
                }
            }
            // 转换
            // 10 - 2 -反转 - 10 -16
            StringBuffer result = new StringBuffer();
            for (int i = 0; i < buf.length(); i++) {
                char ch = buf.toString().charAt(i);
                if ('0' <= ch && ch <= '9') {
                    // Integer.toBinaryString int值转化成二进制形式并返回这个二进制数的字符串
                    String twoNum = Integer.toBinaryString(Integer.parseInt(String.valueOf(ch), 10));
                    StringBuffer sb = new StringBuffer(twoNum);
                    int len = sb.length();
                    if (len < 4) {
                        StringBuffer sb0 = new StringBuffer();
                        for (int j = 0; j <= 4 - len; j++) {
                            sb0.append(0);
                        }
                        sb = sb0.append(sb);
                    }
                    // 反转、 + 转10进制
                    int tenNum = Integer.parseInt(sb.reverse().toString(), 2);
                    // 转16进制
                    result.append(Integer.toHexString(tenNum).toUpperCase());
                } else if (('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')) {
                    int tenNUm = Integer.parseInt(String.valueOf(ch), 16);
                    String twoNum = Integer.toBinaryString(tenNUm);
                    StringBuffer sb = new StringBuffer(twoNum);
                    int tenNum2 = Integer.parseInt(sb.reverse().toString(), 2);
                    result.append(Integer.toHexString(tenNum2).toUpperCase());
                }else {
                    result.append(ch);
                }

            }
            System.out.println(result.toString());
        }
    }      

#### HJ31 单词倒排
    1. 构成单词的字符只能是26个大小写字母；
    2. 非构成单词的字符均视为单词的间隔符；
    3. 要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒转时只允许出现一个空格间隔符；
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String s = sc.nextLine();
            String[] strArr = s.split("[^a-zA-Z]");
            int len = strArr.length;
            StringBuffer result = new StringBuffer();
            for (int i = len-1; i >= 0; i--) {
                result.append(strArr[i]);
                if (i != 0){
                    result.append(" ");
                }
            }
            System.out.println(result.toString());
        }
      
#### HJ32 密码截取（最长回文串）      
        思路：中心扩散法；
        输入：ABBA 输出：4； 输入：ABBBA 输出：5   输入：12HHHHA 输出：4
       public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str = sc.nextLine();
            int len = str.length();
            int endLen = 0;
            // 从第一个字符起，以每个字符为中心点，向两边扩散，求最长的回文串
            for (int i = 0; i < len; i++) {
                int sizeJi = expandAroundCenter(str,i,i);
                int sizeOu = expandAroundCenter(str,i,i+1);
                endLen = Math.max(endLen,Math.max(sizeJi,sizeOu));
            }
            System.out.println(endLen);
        }

        /**
         * 以i，j为中心向两边扩散
         * @param str 字符串
         * @param left 中心点索引
         * @param right 中心点索引
         * @return 长度
         */
        private static int expandAroundCenter(String str, int left, int right) {
            while (left>=0 && right < str.length() && str.charAt(left) == str.charAt(right)){
                left--;
                right++;
            }
            return right - left - 1;
        } 

#### HJ33 整数与IP之间的转换
     * IP地址的每一段可以看成一个0-255的整数，把每一段拆分成一个二进制形式组合起来，然后把这个数变成一个长整数
     * 输入：10.0.3.193 输出：00001010 00000000 00000011 11000001 转换10进制后为167773121；
     
     public static void main(String[] args) {
            Scanner sc  = new Scanner(System.in);
            String str = sc.nextLine();
            String[] strArr = str.split("\\.");
            int len = strArr.length;
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < len; i++) {
                String s = strArr[i];
                int tenNum = Integer.parseInt(s, 10);
                String twoStr = Integer.toBinaryString(tenNum);
                StringBuffer sb1 = new StringBuffer();
                if (twoStr.length() < 8){
                    int zero = 8 - twoStr.length();
                    for (int j = 0; j < zero; j++) {
                        sb1.append(0);
                    }
                }
                sb1.append(twoStr);
                sb.append(sb1);
            }

            long i = Integer.parseInt(sb.toString(), 2);
            System.out.println(i);
        }

#### HJ34 图片整理
    对‘A’到‘Z’；‘a’ 到 ‘z’; ‘0’ 到 ‘9’按ASCII码排序
    输入：Ihave1nose2hands10fingers 输出：0112Iaadeeefghhinnnorsssv
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str = sc.nextLine();
            int len = str.length();
            List<Character> list = new ArrayList<>();
            for (int i = 0; i < len; i++) {
                list.add(str.charAt(i));
            }
            Collections.sort(list);
            StringBuffer sb = new StringBuffer();
            for (Character character : list) {
                sb.append(character);
            }
            System.out.println(sb.toString());
        }

#### HJ35 蛇形矩阵
     蛇形矩阵是由1开始的自然数依次排列成为的一个矩阵上的三角形；
      * 输入：5   输出： 1 3 6 10 15
      *                 2 5 9 14
      *                 4 8 13
      *                 7 12
      *                 11
      
      public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int y = 1;  // 行起始值
            int yCount = 1; // 行间隔起始值；
            // 外层循环控制行
            for (int i = 1; i <= n; i++) {
                int x = y;  // 列起始值
                int xCount =  i + 1; // 列间隔起始值
                // 里层控制列
                for (int j = 1; j <= n - i + 1; j++){
                    if (j == n - i + 1){
                        System.out.println(x);
                    }else {
                        System.out.print(x + " ");
                    }
                    x = x + xCount;
                    xCount++;
                }
                y = y + yCount;
                yCount++;
            }
        }
        
#### HJ36 字符串加密
       输入一个密匙key,如：TRAILBLAZERS; 
       输入：TRAILBLAZERS        nihao
             Attack AT DAWN      ni
       输出： tpptad tp itvh     le
       
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str1 = sc.nextLine().toLowerCase();
            String str2 = sc.nextLine().toLowerCase();
            List<Character> list = new ArrayList<>();

            for (int i = 0; i < str1.length(); i++) {
                if (!list.contains(str1.charAt(i))) {
                    list.add(str1.charAt(i));
                }
            }
            for (int i = 97; i <= 122; i++) {
                char ch = (char) i;
                if (!list.contains(ch)) {
                    list.add(ch);
                }
            }
            int length = str2.length();
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < length; i++) {
                if (97 <= str2.charAt(i) && str2.charAt(i) <= 122){
                    sb = sb.append(list.get(str2.charAt(i) - 97));
                }else {
                    if (str2.charAt(i) == ' '){
                        sb.append(" ");
                    }else {
                        sb = sb.append(Character.toUpperCase(list.get(str2.charAt(i) - 97)));
                    }

                }
            }

            System.out.println(sb.toString());
        }
        
#### HJ37 统计每个月兔子的个数
     * 一种兔子从出生后第3个月开始每月生一只，小兔子长到第3个月后每个月开始生
     * 如果兔子不死，那第那个月会有几只兔子
     * 
     * 思路：本月兔子的个数 = 上个月兔子的总个数 + 所有成年兔子生的个数
     public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()){
            int month = sc.nextInt();
            System.out.println(cal(month));
        }

    }

    private static Integer cal(int month) {
        if (month == 1 || month == 2) {
            return 1;
        }
        return cal(month - 1) + cal(month - 2);
    }

#### HJ38 求小球落地5次后的路程和第5次反弹的高度
     * 假设一个球从任意高度自由下落，求它在第5次落地时，共经历多少米？第五次反弹多高？
     public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            double hight = sc.nextLong();
            double result = hight; // 总路程
            hight = hight / 2; // 第一次落地后高度已经减半
            for (int i = 1; i < 5; i++) {
                result += hight * 2;
                hight = hight / 2;
            }
            System.out.println(result);
            System.out.println(hight);
        }
    }
    
  
#### HJ39 判断两个IP是否属于同一子网
    输入两个IP， 将两个IP转为2进制后，按位与操作后，将得到的2进制在转为10进制得到的值一样则是同一子网 
    同一子网IP 返回 “0”，不是范围“2”，IP或者不合法返回“1”
    有效IP和掩码：1.掩码和IP每一段都在0-255之间；2.掩码的2进制字符换前缀为网络号，都是1，后缀是主机号都是0；
    例：255.255.255.0     255.0.0.0        255.255.255.0
        192.168.224.256   193.194.202.15   192.168.0.254
        192.168.10.4      232.43.7.59      192.168.0.1
        输出 1            2                0
        
            public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            int result = 0;
            String codeStr = sc.nextLine();
            String ipStr1 = sc.nextLine();
            String ipStr2 = sc.nextLine();
            String[] ip1Arr = ipStr1.split("\\.");
            String[] ip2Arr = ipStr2.split("\\.");
            String[] codeArr = codeStr.split("\\.");
            // 校验ip格式
            boolean b = checkFormat(ip1Arr, ip2Arr, codeArr);
            if (b){
                List<String> ip1two = new ArrayList<>();
                List<String> ip2two = new ArrayList<>();
                List<String> codeTwo = new ArrayList<>();
                List<Integer> re1 = new ArrayList<>();
                List<Integer> re2 = new ArrayList<>();
                // 转成2进制数组
                for (int i = 0; i < 4; i++) {
                    ip1two.add(Integer.toBinaryString(Integer.parseInt(ip1Arr[i], 10)));
                    ip2two.add(Integer.toBinaryString(Integer.parseInt(ip2Arr[i], 10)));
                    codeTwo.add(Integer.toBinaryString(Integer.parseInt(codeArr[i], 10)));
                }
                // 按位与
                for (int i = 0; i < 4; i++) {
                    re1.add(Integer.parseInt(ip1two.get(i), 2) & Integer.parseInt(codeTwo.get(i), 2));
                    re2.add(Integer.parseInt(ip2two.get(i), 2) & Integer.parseInt(codeTwo.get(i), 2));
                }
                for (int i = 0; i < 4; i++) {
                    if (!re1.get(i).equals(re2.get(i))) {
                        result = 2;
                        break;
                    }
                }
                System.out.println(result);
            }else {
                System.out.println(1);
            }

        }
    }

    private static boolean checkFormat(String[] ip1Arr, String[] ip2Arr, String[] codeArr) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 4; i++) {
            if (0 > Integer.parseInt(ip1Arr[i], 10) || 255 < Integer.parseInt(ip1Arr[i], 10)) {
               return false;
            }
            if (0 > Integer.parseInt(ip2Arr[i], 10) || 255 < Integer.parseInt(ip2Arr[i], 10)) {
                return false;
            }
            if (0 > Integer.parseInt(codeArr[i], 10) || 255 < Integer.parseInt(codeArr[i], 10)) {
                return false;
            }
            String str = Integer.toBinaryString(Integer.parseInt(codeArr[i], 10));
            while (str.length() <8){
                str = "0" + str;
            }
            sb.append(str);
        }
        int left = 0;
        int right = 31;
        while (sb.charAt(left) == '1'){
            left++;
        }
        while (sb.charAt(right) == '0'){
            right--;
        }
        if (left != right + 1){
            return false;
        }
        return true;
    }

#### HJ40 统计字符
    输入一行字符，分别统计出包含英文字母，空格，数字，和其他字符的个数
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()){
            String source = sc.nextLine();
            int letters = 0;
            int numbers = 0;
            int kong = 0;
            int other = 0;
            int len = source.length();
            for (int i = 0; i < len; i++) {
                char ch = source.charAt(i);
                if ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z'){
                    letters++;
                }else if ('0' <= ch && ch <= '9'){
                    numbers++;
                }else if (ch == ' '){
                    kong++;
                }else {
                    other++;
                }
            }
            System.out.println(letters);
            System.out.println(kong);
            System.out.println(numbers);
            System.out.println(other);
            
        }
    }
