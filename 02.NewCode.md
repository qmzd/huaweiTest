#### 1. 第一道是快乐消消乐，就是给定一个字符串将相邻的两个字符进行消除，最后返回消除后字符串的总长数  (真题)
    例子： ggA, 结果 1
    消除 gg 后剩下 A ，因此最后结果 1
    例子2：abccbe，结果 2
    消除 cc 后字符串变成 abbe 在消除 bb，变 ae，因此结果 2
    
        public static String xiaoXiaoLe(String str){
          int length = str.length();
          Deque<Character> stack = new LinkedList<>();
          for (int i = 0 ; i<length; i++){
              char ch = str.charAt(i);
              if (stack.isEmpty()){
                  stack.push(ch);
                  continue;
              }
              if (stack.peek() == ch){
                  stack.pop();
              }else {
                  stack.push(ch);
              }
          }
          return String.valueOf(stack.size());
      }
      
#### 2.给两个字符串，targe，和 source，查找 targe 是否由 source 删除某些字符得到的，是返回开始的最大下标，否返回 -1; （真题-解法有误）
       例子：
       输入：
       abc
       abcaybec
       结果为 3
       解释：abc 可以由下面 abcaybec 删除 aybec 和 abcye 而来，删除 abcye 是最后的这个组成的 a 在下标位置 3 下，因此返回 3
       
            public static int targeAndSource(String targe, String source){
                int tarStr = targe.length();
                int sourStr = source.length();
                if (sourStr < tarStr || targe.isEmpty() || source.isEmpty()){
                    return -1;
                }
                Map<Character,Integer> map = new HashMap<>();
                for (int i = 0; i < tarStr; i++){
                    char tarCh = targe.charAt(i);
                    for (int j =0; j < sourStr-tarStr; j++){
                        char sourCh = source.charAt(j);
                        if (sourCh != tarCh){
                            continue;
                        }else {
                            map.put(sourCh,j);
                        }

                        if (map.size() == tarStr){
                            return j+1;
                        }

                    }
                }
                return -1;
            }
            
#### 3.放苹果
        把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。

        数据范围：0≤m≤10 ，1≤n≤10 。

        本题含有多组样例输入。
        输入：7 3
        输出：8
        解题思路：设f(m,n)为m个苹果，n个盘子的放法数目，则先对n作讨论，
　　　* 当n>m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n>m)f(m,n)=f(m,m)
　　　* 当n<=m：不同的放法可以分成两类：
　　　* 
　　　　(a)有至少一个盘子空着，即相当于f(m,n)=f(m,n-1);
    
　　　　(b)所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n)=f(m-n,n).而总的放苹果的放法数目等于两者的和，即f(m,n)=f(m,n-1)+f(m-n,n)递归出口条件说明：当n=1           时，所有苹果都必须放在一个盘子里，所以返回1；当没有苹果可放时，定义为1种放法；递归的两条路，第一条n会逐渐减少，终会到达出口n==1;第二条m会逐渐减少，因为n>m时，我们会returnf(m,m)　             所以终会到达出口m==0．
　　综上递推公式为：

            import java.util.Scanner;
            public class Main{
              public static void main(String args[]){
                 Scanner scan =  new Scanner(System.in);
                 while(scan.hasNextInt()){
                     int apple = scan.nextInt();
                     int pan = scan.nextInt();
                     System.out.println(cal(apple,pan));
                 }
              }

                public static int cal (int apple,int pan){
                    /* 分苹果可分为两种情况：
                      f(a,p) 为可以分的次数,a为苹果；p为盘子；
                      对p进行讨论，
                      第一种情况：p>a 时，p-a个盘子永远是空着的，不考虑，f(p,p)
                      第二种情况：a > p时，分一下两种情况：
                         1.至少有一个盘子是空着的；f(a,p) = f(a,p-1)
                         2.所有的盘子都有苹果；f(a,p) = f(a-p,p);
                         总情况数等于 f(a,p-1) + f(a-p,p) ;
                         递归的出口是当a = 1 时 return 1;
                                   当p = 1 时 return 0;
                    */
                    if(apple < 0 || pan <= 0){
                       return 0;
                    }
                     //细分到苹果数为一或盘子数为一的情况返回一
                    if(apple == 1 || pan == 1 || apple == 0){
                        return 1;
                    }
                   return cal(apple,pan-1) + cal(apple - pan, pan);
                }
            }
