#### 1. 第一道是快乐消消乐，就是给定一个字符串将相邻的两个字符进行消除，最后返回消除后字符串的总长数  (真题)
    例子： ggA, 结果 1
    消除 gg 后剩下 A ，因此最后结果 1
    例子2：abccbe，结果 2
    消除 cc 后字符串变成 abbe 在消除 bb，变 ae，因此结果 2
    
        public static String xiaoXiaoLe(String str){
          int length = str.length();
          Deque<Character> stack = new LinkedList<>();
          for (int i = 0 ; i<length; i++){
              char ch = str.charAt(i);
              if (stack.isEmpty()){
                  stack.push(ch);
                  continue;
              }
              if (stack.peek() == ch){
                  stack.pop();
              }else {
                  stack.push(ch);
              }
          }
          return String.valueOf(stack.size());
      }
      
#### 2.给两个字符串，targe，和 source，查找 targe 是否由 source 删除某些字符得到的，是返回开始的最大下标，否返回 -1; （真题-解法有误）
       例子：
       输入：
       abc
       abcaybec
       结果为 3
       解释：abc 可以由下面 abcaybec 删除 aybec 和 abcye 而来，删除 abcye 是最后的这个组成的 a 在下标位置 3 下，因此返回 3
       
            public static int targeAndSource(String targe, String source){
                int tarStr = targe.length();
                int sourStr = source.length();
                if (sourStr < tarStr || targe.isEmpty() || source.isEmpty()){
                    return -1;
                }
                Map<Character,Integer> map = new HashMap<>();
                for (int i = 0; i < tarStr; i++){
                    char tarCh = targe.charAt(i);
                    for (int j =0; j < sourStr-tarStr; j++){
                        char sourCh = source.charAt(j);
                        if (sourCh != tarCh){
                            continue;
                        }else {
                            map.put(sourCh,j);
                        }

                        if (map.size() == tarStr){
                            return j+1;
                        }

                    }
                }
                return -1;
            }
            
#### 3.放苹果
        把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。

        数据范围：0≤m≤10 ，1≤n≤10 。

        本题含有多组样例输入。
        输入：7 3
        输出：8
        解题思路：设f(m,n)为m个苹果，n个盘子的放法数目，则先对n作讨论，
        
       （1）当n>m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n>m)f(m,n)=f(m,m)
       
       （2）当n<=m：不同的放法可以分成两类：

　　　　   (a)有至少一个盘子空着，即相当于f(m,n)=f(m,n-1);
    
　　　　   (b)所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n)=f(m-n,n).而总的放苹果的放法数目等于两者的和，即f(m,n)=f(m,n-1)+f(m-n,n)递归出口条件说明：当n=1 时，所有苹果都必须放在一个盘子里，所以返回1；当没有苹果可放时，定义为1种放法；递归的两条路，第一条n会逐渐减少，终会到达出口n==1;第二条m会逐渐减少，因为n>m时，我们会returnf(m,m)　             所以终会到达出口m==0．
　　综上递推公式为：

            import java.util.Scanner;
            public class Main{
              public static void main(String args[]){
                 Scanner scan =  new Scanner(System.in);
                 while(scan.hasNextInt()){
                     int apple = scan.nextInt();
                     int pan = scan.nextInt();
                     System.out.println(cal(apple,pan));
                 }
              }

                public static int cal (int apple,int pan){
                    /* 分苹果可分为两种情况：
                      f(a,p) 为可以分的次数,a为苹果；p为盘子；
                      对p进行讨论，
                      第一种情况：p>a 时，p-a个盘子永远是空着的，不考虑，f(p,p)
                      第二种情况：a > p时，分一下两种情况：
                         1.至少有一个盘子是空着的；f(a,p) = f(a,p-1)
                         2.所有的盘子都有苹果；f(a,p) = f(a-p,p);
                         总情况数等于 f(a,p-1) + f(a-p,p) ;
                         递归的出口是当a = 1 时 return 1;
                                   当p = 1 时 return 0;
                    */
                    if(apple < 0 || pan <= 0){
                       return 0;
                    }
                     //细分到苹果数为一或盘子数为一的情况返回一
                    if(apple == 1 || pan == 1 || apple == 0){
                        return 1;
                    }
                   return cal(apple,pan-1) + cal(apple - pan, pan);
                }
            }
#### HJ5 进制转换
    接收一个16进制的数，输出为该数值的10进制数；
    输入：0xA ， 0xAA
    输出：10,170
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            while (sc.hasNext()){
                String str = sc.next();
                String subStr = str.substring(2, str.length());
                int result = Integer.parseInt(subStr, 16);
                System.out.println(result);
            }
        }
    
#### HJ6 质数因子
    输入一个正整数，按照从小到大的顺序输出它的所有质数因子（重复的也要列举）；
    例：输入 180
        输出 2 2 3 3 5
   解题思路：1. 对于一个数，他的质因数必然分布在该数的平方根两侧，而且**大于平方根的质因数最多只有一个，且必然是分解到最后所剩余的商**。    
             2. 取余： a%b=a-(a/b)*b
             
             public static void main(String[] args) {
                    Scanner sc = new Scanner(System.in);
                    long num = sc.nextLong();
                    double sqrt = Math.sqrt(num);
                    for (long i = 2; i <= sqrt; i++){
                        while (num % i == 0){
                            System.out.print(i + "");
                            num /= i;
                        }
                    }
                    System.out.println();
                }
                
#### HJ7 取近似值
    写一个程序，接收一个正浮点数值，输出该数值的近似整数值。若果小数点后数>=0.5,向上取整，<0.5,向下取整。
    例：输入：5.5
        输出： 6
      
            public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                float v = sc.nextFloat();
                int round = Math.round(v);
                System.out.println(round);
            }
            
#### HJ8 合并表记录      
    数据表记录包含表索引和数值（int 范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值求和，输出按照key值升序
    0 <= index <= 1111111
    1 <= value <= 100000
    先输入键值对的个数n，然后输入键值对，以空格隔开；
    例：  4 
          0 1
          0 2
          1 2
          3 4
          
   返回值
          0 3          
          1 2          
          3 4   
          
          
       public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            while (sc.hasNext()) {
                int count = sc.nextInt();
                Map<Integer, Integer> map = new TreeMap<>();
                for (int i = 0; i < count; i++) {
                    int key = sc.nextInt();
                    int value = sc.nextInt();
                    if (map.containsKey(key)) {
                        value = map.get(key) + value;
                    }
                    map.put(key, value);
                }
                Set<Integer> keys = map.keySet();
                for (Integer key : keys) {
                    System.out.println(key + " " + map.get(key));
                }
            }
        }   
        
#### HJ9 提取不重复数
    输入一个Int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数；
    保证最后一位不是0
    例：输入 9876673； 输出：37689
    
     public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int target = sc.nextInt();
            String str = String.valueOf(target);
            int size = str.length();
           List<Character> list = new ArrayList<>();
            while (size != 0) {
                size--;
                if (!list.contains(str.charAt(size))){
                    list.add(str.charAt(size));
                }
            }
            StringBuffer sb = new StringBuffer();
            for (Character character : list) {
                sb.append(character);
            }
            System.out.println(Integer.parseInt(sb.toString()));
        }
        
#### HJ10 字符个数统计       
    编写一个函数，计算字符串中含有的不同字符的个数。字符在ASCII码范围内（0~127,包含0和127）
    换行表示结束符，不再计算范围之内。多个相符的字符只计算一次；比如abaca 只有a,b,c三个不同的字符，输出3；
    
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String str = sc.nextLine();
            Map<Character,Character> map = new TreeMap<>();
            int size = str.length();
            for (int i = 0; i < size; i++) {
                char ch = str.charAt(i);
                if (map.containsKey(str.charAt(i))){
                    continue;
                }
                map.put(ch,ch);
            }
            System.out.println(map.size());
        }
